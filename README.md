# Задача А008: Сложное метро

Класс `Subway` принимает шаблонный параметр `T`, обозначающий тип для хранения ответа/времен. 

Методы:

* `init`: принимает параметры
	* `n`: число станций метро
	* `paths`: ветки, каждая задается списком номеров станций, нумерация начинается с 0
	* `lengths`: времена проезда между станциями в ветках, каждая ветка задается списком длины на 1 меньше соответствующего списка в `paths` времен проезда между соседними станциями в ветке.
	* `time`: список интервалов между поездами на соответствующей ветке
* `get`: принимает параметры
	* `start`: начальная станция метро в нумерации с 0
	* `finish`: конечная станция метро в нумерации с 0
	* `start_time`: время входа в метро
	* возвращает пару из минимального времени, в которое можно достичь станцию `finish`, а также количества пересадок для этого. Если достичь станцию `finish` невозможно, время равно -1.
* `get_lazy`: параметры и возвращаемое значение аналогично функции `get`. Ищет путь с минимальным числом пересадок с учетом того, что время, потраченное на поездку не превышает 1.5 * минимально возможное время.
## Простая версия
Применим алгоритм Дейкстры на каждую функцию `get`, время работы составит O(n * log(n) + S) на запрос, где S равно сумме квадратов количества станций в каждой ветке.
## Сложная версия
С помощью простой версии найдем нижнюю границу на число пересадок, обозначим ее за k. Тогда посчитаем массив dp размера n x (k + 1), где dp[v][i] равно минимальному времени для того, чтобы попасть из начальной станции в станцию v, сделав i пересадок. Время работы составит O(n * log(n) + S + k * s) на запрос, где s равно суммарному числу станций во всех ветках. Как считаем массив dp : для каждой ветки делаем dp[u] = dp[v] + p[u] - p[v], а если u дальше v, то dp[u] = (dp[v] - p[v]) + p[u]. По всем v раньше u находим минимум по этой функции for-ом. Аналогично в другую сторону (ветка двусторонняя)
